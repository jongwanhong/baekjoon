# 01타일 - dp
# 각각의 타일들은 0 또는 1이 쓰여있음
# 0이 쓰여진 낱장의 타일들을 붙여 한 쌍으로 이루어진 00 타일을 만듦
# 1하나만으로 이루어진 타일, 00타일들만 남게 됨

# 타일이 무한히 많다고 가정했을 때 N이 주어지면 만들 수 있는 모든 가짓수를 셈

# 입력 - N
# 출력 - 만들 수 있는 길이가 N인 모든 2진 수열의 개수를 15746으로 나눈 나머지를 출력

# 점화식을 구해보려 잠시 확장해보면
# f(1) = 1, f(2) = 2, f(3)=3,
# 0011 1100 1001 0000 1111 - f(4)=5
# 00001 00100 10000 00111 10011 11001 11100 11111 f(5)=8
# 원래 확실히 하려면 더 확장해봐야지만.. 딱봐도 초항이 다른 피보나치의 점화식이다
# f(n) = f(n-1) + f(n-2) -> 재귀를 하면 시간초과 뜰거고, dp 문제이므로 메모이제이션 활용!

# # 메모이제이션 - 메모리 초과.. 재귀 부분에서도 15746으로 나눠주지 않으면 recursion error 발생
# import sys

# n = int(input())

# memo = {
#     1: 1,
#     2: 2,
# }

# def tile(n, memo):
#     if n in memo:
#         return memo[n]
#     result = tile((n-1), memo) % 15746 + tile((n-2), memo) % 15746
#     memo[n] = result
#     return result % 15746

# sys.setrecursionlimit(10**6)
#print(tile(n, memo))

# dp - bottom up
# 단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출 - 바텀 업
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 1000001

# 초항 설정
d[1] = 1
d[2] = 2
n = int(input())

# 피보나치 함수 반복문으로 구현(바텀 업 다이나믹 프로그래밍)
for i in range(3, n + 1):
    d[i] = (d[i - 1] + d[i - 2]) % 15746  # 15746 으로 나눠주어 불필요한 메모리 손실 방지?

print(d[n])
